---
title: "2024.07 blog review"
date: 2024-07-01T17:40:57+08:00
draft: false
toc: false
description: 汇总每个月看过的一些觉得不错的文章
tags: 
  - blog
---

# Database

### BG3: A Cost Effective and I/O Efficient Graph Database in ByteDance
https://db.in.tum.de/teaching/ss16/moderndbs/chapter8.pdf

ByteGraph的优化。主要是几点：
  1. 底层存储从KV换为Append-Only的BlobStorage。原因是BlobStorage可以提供与硬件能力接近的吞吐，也可以自行控制数据分布和GC。而KV一般是基于LSM模型，需要预留更多的带宽来做Compaction，性能 也比较un-predictable。其实说白了就是KV更黑盒，这个抽象是有代价的.
  2. 基于BlobStorage构建BW-Tree。其中BW-Tree可以per user，降低写写冲突；并且delta node会包含了先前的所有delta node数据，这样在读的时候就不需要merge所有delta，优化读
  3. 负载感知的Reclamation
  4. 通过Log实现RO节点的强一致读
   
### Hybrid Garbage Collection for Multi-Version Concurrency Control in SAP HANA
https://15721.courses.cs.cmu.edu/spring2019/papers/05-mvcc3/p1307-lee.pdf

  SAP HANA关于MVCC垃圾收集的一些优化
  1. 为了避免long-run的OLAP事务导致垃圾回收savepoint水位一 直无法前进，引入了间隔垃圾回收。就是比如说版本链是[1,3,4,10]，活跃事务是[2,100] ，那其实可以直接把3和4给回收掉。跟HyPer一样
  2. 组垃圾回收。给每个版本数据维护一个指针，指向产生它的事务，如果这个版本数据可以被回收，那么这个事务产生的所有数据其实都可以被回收
  3. 表垃圾回收。简单来说就是比如说如果一个活跃事务只会访问表a，那么表b的历史版本gc就不需要受到这个活跃事务影响了。但是只能用在能完全确定事务所读表的场景，比如RC隔离级别的一个statement，或者SI的存储过程


# Storage

### Overcoming the Memory Wall with CXL-Enabled SSDs
https://www.usenix.org/system/files/atc23-yang-shao-peng.pdf

计算能力增长远远快于内存容量, 所谓内存墙

CXL允许CPU直接访问PCIe设备用作主内存,但使用闪存作为主内存存在三个主要挑战: 
1. 内存请求和闪存的粒度不匹配
2. 闪存的延迟远远慢于DRAM
3. 闪存的寿命有限

咋解决？加一层Cache&Buffer，Over

# Others
### jemalloc 引起的 TLB shootdown 及优化
https://blog.csdn.net/ByteDanceTech/article/details/104765810
一次因jemalloc的madvice引起的TLB Shootdown
1. /proc/interrupts 发现是TLB shootdown
2. 解决方案：禁用jemalloc的madvice

### Don’t shoot down TLB shootdowns!
https://nadav.amit.zone/publications/amit2020tlb.html

减少TLB shootdown的开销

  1. 本地TLB flush和remote TLB shootdown并法执行，省掉一次本地flush的时间
  2. remote TLB shootdown可以在进入中断处理程序后马上ack， 而不需要等到真的flush了

其他看不懂